I"+"<h2 id="problem">Problem</h2>
<p>It is fairly easy to recognize <strong>price momentum</strong> with price-based indicators ex-post or with lag.  Price based 
momentum signals tend to have <strong>lag issues</strong> in recognizing the start and end of a price move as there is a <strong>tradeoff between 
noise and lag</strong> [1] that can’t be defeated without future information (due to principles from signal processing).</p>

<p>[1] For those interested see <strong>impulse-response</strong> and the relationship between <strong>response delay</strong> and degree of smoothing by
a filter.  Zero lag smoothing with a traditional filter can only be achieved with Forward-Backward smoothing (using data from the future).</p>

<h2 id="buy--sell-imbalance">Buy / Sell Imbalance</h2>
<p>In <strong>lit markets</strong> (where we can see orders and trades), there is additional information that can be applied towards recognizing
price moves (or at least directional trading):</p>

<ul>
  <li><strong>advertised size on the orderbook</strong>
    <ul>
      <li>though one has to be careful about spoofing and other techniques to mask or mislead on direction</li>
    </ul>
  </li>
  <li><strong>skewed activity in the orderbook</strong>
    <ul>
      <li>order placement, cancelation activity pointing to algo or trader buying</li>
    </ul>
  </li>
  <li><strong>trades</strong>: whether a buyer or seller aggressed
    <ul>
      <li>every crossed order involves two trades.  The order that crossed with a standing order is the aggressing order and the
aggressing side (buy or sell).</li>
    </ul>
  </li>
</ul>

<p>In this case we will focus on trades.  Most price moves above a certain magnitude will show skewed buying (selling) activity
where the majority of aggressive crossing orders are in one direction.  Some markets provide an indication of which
side aggressed a specific trade:</p>

<ul>
  <li><strong>CME / Globex and associated futures exchanges</strong>
    <ul>
      <li>provides a flag to indicate side of trade for orders placed at prices above the BBO (best bid, best offer)</li>
    </ul>
  </li>
  <li><strong>Crypto exchanges</strong>
    <ul>
      <li>provide aggressing side for all exchange trades</li>
      <li>note that big trades are often done OTC, however, and therefore not visible except in the blockchain eventually</li>
    </ul>
  </li>
  <li><strong>EBS</strong> (FX)
    <ul>
      <li>it has been a while since I used EBS, but believe EBS Live provides a sampling of trades with aggressor side</li>
    </ul>
  </li>
</ul>

<p>There are many other exchanges which provide trades, however without buy/sell attribution:</p>

<ul>
  <li>equity exchanges</li>
  <li>some non-bank FX venues</li>
  <li>various bond venues</li>
  <li>…</li>
</ul>

<p>Early research into buy / sell imbalance focused on <strong>classification of trades</strong> as <em>buyer initiated</em> or <em>seller initiated</em>. 
Probably the first published approach in this regard was the <strong>Lee-Ready</strong> technique (circa 1991), which made use of the 
position of a given trade’s price relative to a prior BBO mid-point to determine whether was likely buyer or seller
originated.  This was followed by a variety of alternative approaches, one of which will discuss in a later post.  Here is
a <a href="https://quant.stackexchange.com/questions/8843/what-are-modern-algorithms-for-trade-classification">good reference</a> to 
some of the approaches.</p>

<p>Trade volume tends to be clustered and is best modeled with a <strong>point process</strong> (in particular a <strong>Hawkes Process</strong>).   The
Hawkes process is a counting process that <strong>models the arrival of events over time</strong>.  In this case would be used to
model the arrival of unitary buyer or seller originated orders at time t.   The process is <em>“self exciting”</em> in that
each arrival (trade) excites the process, in the sense that the frequency and magnitude of subsequent arrivals (trades)
is increased (and decays once new arrivals diminish).  This is expressed as:</p>

\[H(t) = \mu (t) + \sum_{t_i &lt; t} N(t_i) e^{-\kappa (t - t_i)}\]

<p>where \(\mu (t)\) is the mean arrival rate, \(N(t_i)\) is the magnitude or number events at time
\(t_i\) and \(\kappa\) is the decay.  When the decay (\(\kappa\)) is small, an event will excite the process
for a longer period of time.</p>

<p>For our buy / sell indicator we will evaluate it as follows:</p>

<ul>
  <li>let \(\mu (t)\) be 0, since we expect an even number of buys and sells as the baseline behavior</li>
  <li>\(N(t_i)\) is the magnitude of buys - sells per bar (or if evaluating per trade, would be the sign and magnitude of the trade)</li>
</ul>

<p>This is realized as:</p>

\[BSI(t) = \sum_{t_i &lt; t} (buyvolume_{t_i} - sellvolume_{t_i}) e^{-\kappa (t - t_i)}\]

<p>Or as a recurrence relation:</p>

\[BSI(t) = BSI(t-1) e^{-\kappa \Delta t} + (buyvolume_{t_i} - sellvolume_{t_i})\]

<h2 id="discussion--examples">Discussion &amp; Examples</h2>
<p>The buy sell imbalance usually develops <strong>ahead of a visible price move</strong>, as trading drives price moves.  If you have access to 
a full view of the market or a particular exchange where the move originates, should see an early indication of buy/sell imbalance, 
presaging the move.  However, one may not have full visibility on the market, the visible slice will be a proxy for the overall activity
behind the move.</p>

<p>In either case, I have found that BSI:</p>

<ul>
  <li>can be an early signal prior to or at inception of move</li>
  <li>provides better information as to when to exit than price-based indicators</li>
</ul>

<h3 id="example-1">Example 1</h3>
<p>In this particular example, I did not have access to all trades across the market, just trades from one source (a market for Gold).
The initial trading for this move started 5 minutes before the large drop (I believe), but most of it traded away from this market
early on or was done passively.  Hence BSI, here, only signals once the pace of trading becomes apparent on the futures exchange.</p>

<p>Find the code for this example in my new open-sourced timeseries patterns library <a href="https://github.com/tr8dr/tseries-patterns">tseries-patterns</a>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"csv/volumebars.csv"</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="p">[</span><span class="s">'stamp'</span><span class="p">])</span>

<span class="n">bsi</span> <span class="o">=</span> <span class="n">HawkesBSI</span><span class="p">(</span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">bsi</span><span class="p">.</span><span class="nb">eval</span> <span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">bsi</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">"variation with kappa = 0.1"</span><span class="p">)</span>
</code></pre></div></div>
<p><img src="/assets/2020-08-03/BSI1.png" alt="BSI Plot" /></p>

<p>Here is the same time period with a faster decay:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bsi</span> <span class="o">=</span> <span class="n">HawkesBSI</span><span class="p">(</span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">bsi</span><span class="p">.</span><span class="nb">eval</span> <span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">bsi</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">"variation with kappa = 0.5"</span><span class="p">)</span>
</code></pre></div></div>
<p><img src="/assets/2020-08-03/BSI2.png" alt="BSI Plot" /></p>

<h2 id="implementation">Implementation</h2>
<p>I have implemented BSI and variants thereof in C++, F#, Kotlin, and Python over the years.  As mentioned above, have created an open source 
Python library, where am starting to share some of the indicators I use, called <a href="https://github.com/tr8dr/tseries-patterns">tseries-patterns</a>.
Will be adding to this library over time, so suggest watching the repository if is of interest.  Appreciate any feedback.</p>

:ET